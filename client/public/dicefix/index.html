<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dice Face Mapper</title>
    <style>
      body {
        margin: 0;
        background: #0e1729;
        color: #e8edf7;
        font-family: 'Inter', system-ui, -apple-system, sans-serif;
        display: flex;
        height: 100vh;
      }
      #ui {
        width: 360px;
        padding: 14px;
        background: #111c33;
        border-right: 1px solid rgba(255, 255, 255, 0.06);
        box-sizing: border-box;
      }
      #ui h2 {
        margin-top: 0;
      }
      label {
        display: block;
        margin: 8px 0 4px;
        color: #9db0d3;
        font-size: 0.9rem;
      }
      select,
      button,
      textarea {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        background: #0b1426;
        color: #e8edf7;
        font-size: 0.95rem;
      }
      #mapView {
        width: 100%;
        min-height: 140px;
        font-family: monospace;
        margin-top: 12px;
      }
      #canvasWrap {
        flex: 1;
        position: relative;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/examples/jsm/loaders/OBJLoader.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/OBJLoader.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="ui">
      <h2>Dice Face Mapper</h2>
      <p style="color:#9db0d3;">Rotate the die, pick the value for the face pointing up, and click assign.</p>
      <p style="color:#9db0d3;">Or click a face in the viewport to assign the selected value.</p>
      <label>Current Top Face Value</label>
      <select id="faceValue">
        <option value="1">1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
      </select>
      <button id="assignBtn" style="margin-top:10px;">Assign to Current Up</button>
      <div style="margin-top:12px; display:grid; grid-template-columns:repeat(3,1fr); gap:6px; align-items:center; justify-items:center;">
        <div></div>
        <button id="rotUp" title="Rotate Up">↑</button>
        <div></div>
        <button id="rotLeft" title="Rotate Left">←</button>
        <button id="rotDown" title="Rotate Down">↓</button>
        <button id="rotRight" title="Rotate Right">→</button>
      </div>
      <label style="margin-top:12px;">Current Map (copy into code)</label>
      <textarea id="mapView" rows="6" readonly></textarea>
      <button id="resetBtn" style="margin-top:10px;">Reset Map</button>
      <p id="loadStatus" style="color:#f4c66d;font-size:0.85rem;margin-top:12px;"></p>
      <p id="upLabel" style="color:#9db0d3;font-size:0.9rem;margin-top:6px;">Current up normal: [0,1,0]</p>
    </div>
    <div id="canvasWrap">
      <canvas id="view" style="background:#0a1324;"></canvas>
    </div>
    <script type="module">
      import * as THREE from 'three';
      import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

      const faceMap = {}; // value -> normal

      const canvas = document.getElementById('view');
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
      camera.position.set(0, 3, 6);
      camera.lookAt(0, 1, 0);

      scene.add(new THREE.AmbientLight(0xffffff, 0.8));
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(5, 8, 6);
      scene.add(dir);

      const boardGeo = new THREE.PlaneGeometry(10, 10);
      const boardMat = new THREE.MeshBasicMaterial({ color: 0x0f1b31 });
      const board = new THREE.Mesh(boardGeo, boardMat);
      board.rotation.x = -Math.PI / 2;
      scene.add(board);

      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const hitMarker = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), new THREE.MeshBasicMaterial({ color: 0xffcc00 }));
      hitMarker.visible = false;
      scene.add(hitMarker);

      // World up arrow (red) and die up arrow (green)
      const worldArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0.2, 0), 1.2, 0xff5555);
      const dieArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1.2, 0), 1.4, 0x5cf0a7);
      scene.add(worldArrow);
      scene.add(dieArrow);

      let die;
      const loader = new OBJLoader();
      loader.load(
        '../assets/Dice.obj',
        (obj) => {
          const tex = new THREE.TextureLoader().load('../assets/dice_diffuse.png');
          tex.colorSpace = THREE.SRGBColorSpace;
          obj.traverse((c) => {
            if (c.isMesh) {
              c.material = new THREE.MeshStandardMaterial({ map: tex });
            }
          });
          die = obj;
          scene.add(die);
          die.position.y = 1;
          document.getElementById('loadStatus').textContent = 'Model loaded. Rotate and assign faces.';
          controls.update();
          updateMapView();
        },
        undefined,
        (err) => {
          console.error(err);
          document.getElementById('loadStatus').textContent = 'Failed to load OBJ. Using fallback cube.';
          const geom = new THREE.BoxGeometry(2, 2, 2);
          const mat = new THREE.MeshStandardMaterial({ color: 0x5cf0a7, wireframe: true });
          die = new THREE.Mesh(geom, mat);
          die.position.y = 1;
          scene.add(die);
          controls.update();
          updateMapView();
        }
      );

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.enablePan = false;
      controls.target.set(0, 1, 0);

      function onResize() {
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', onResize);
      onResize();

      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        if (die) {
          const n = getUpVector();
          dieArrow.position.copy(die.position);
          dieArrow.setDirection(n.clone().normalize());
          document.getElementById('upLabel').textContent = `Current up normal: [${n.x.toFixed(
            2
          )}, ${n.y.toFixed(2)}, ${n.z.toFixed(2)}]`;
        }
        renderer.render(scene, camera);
      }
      animate();

      function getUpVector() {
        if (!die) return new THREE.Vector3(0, 1, 0);
        let up = new THREE.Vector3(0, 1, 0);
        // find first mesh
        let mesh = null;
        die.traverse((c) => {
          if (mesh) return;
          if (c.isMesh) mesh = c;
        });
        if (!mesh) return new THREE.Vector3(0, 1, 0);
        // compute world quaternion of the mesh
        const q = new THREE.Quaternion();
        mesh.getWorldQuaternion(q);
        const n = up.clone().applyQuaternion(q);
        n.normalize();
        return n;
      }

      function getUpNormal() {
        const n = getUpVector();
        return [round(n.x), round(n.y), round(n.z)];
      }

      function round(v) {
        return Math.round(v * 100) / 100;
      }

      canvas.addEventListener('click', (event) => {
        if (!die) return;
        const rect = canvas.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const meshes = [];
        die.traverse((c) => {
          if (c.isMesh) meshes.push(c);
        });
        const hit = raycaster.intersectObjects(meshes, true)[0];
        if (hit) {
          const normal = hit.face.normal.clone().transformDirection(hit.object.matrixWorld).normalize();
          const worldPoint = hit.point;
          hitMarker.position.copy(worldPoint);
          hitMarker.visible = true;
          const val = document.getElementById('faceValue').value;
          faceMap[val] = [round(normal.x), round(normal.y), round(normal.z)];
          updateMapView();
        }
      });

      document.getElementById('assignBtn').addEventListener('click', () => {
        const val = document.getElementById('faceValue').value;
        const normal = getUpNormal();
        faceMap[val] = normal;
        updateMapView();
      });

      document.getElementById('resetBtn').addEventListener('click', () => {
        for (const k of Object.keys(faceMap)) delete faceMap[k];
        updateMapView();
      });

      const rotStep = Math.PI / 8;
      document.getElementById('rotUp').addEventListener('click', () => spinDie(-rotStep, 0));
      document.getElementById('rotDown').addEventListener('click', () => spinDie(rotStep, 0));
      document.getElementById('rotLeft').addEventListener('click', () => spinDie(0, rotStep));
      document.getElementById('rotRight').addEventListener('click', () => spinDie(0, -rotStep));

      function spinDie(xAngle, yAngle) {
        if (!die) return;
        die.rotateX(xAngle);
        die.rotateY(yAngle);
      }

      function updateMapView() {
        const sorted = Object.keys(faceMap)
          .sort((a, b) => Number(a) - Number(b))
          .map((k) => `  ${k}: [${faceMap[k].join(', ')}]`)
          .join(',\n');
        document.getElementById('mapView').value = `const faceMap = {\n${sorted}\n};`;
      }
    </script>
  </body>
</html>
